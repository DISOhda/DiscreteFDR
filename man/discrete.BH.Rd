% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/discreteBH_fun.R
\name{discrete.BH}
\alias{discrete.BH}
\alias{discrete.BH.default}
\alias{discrete.BH.DiscreteTestResults}
\title{The Discrete Benjamini-Hochberg Procedure}
\usage{
discrete.BH(test.results, ...)

\method{discrete.BH}{default}(
  test.results,
  pCDFlist,
  alpha = 0.05,
  direction = "su",
  adaptive = FALSE,
  ret.crit.consts = FALSE,
  threshold = 1,
  pCDFlist.indices = NULL,
  ...
)

\method{discrete.BH}{DiscreteTestResults}(
  test.results,
  alpha = 0.05,
  direction = "su",
  adaptive = FALSE,
  ret.crit.consts = FALSE,
  threshold = 1,
  ...
)
}
\arguments{
\item{test.results}{either a numeric vector with observed p-values or an R6 object of class \code{\link[DiscreteTests]{DiscreteTestResults}} from package \link[DiscreteTests]{DiscreteTests} for which a discrete FDR procedure is to be performed.}

\item{...}{further arguments to be passed to or from other methods. They are ignored in these functions.}

\item{pCDFlist}{list of the supports of the CDFs of the p-values; each list item must be a numeric vector, which is sorted in increasing order and whose last element equals 1.}

\item{alpha}{single real number strictly between 0 and 1 indicating the target FDR level.}

\item{direction}{single character string specifying whether to conduct a step-up (\code{"su"}; the default) or step-down procedure (\code{"sd"}).}

\item{adaptive}{single boolean specifying whether to conduct an adaptive procedure or not.}

\item{ret.crit.consts}{single boolean specifying whether critical constants are to be computed and returned.}

\item{threshold}{single real number strictly between 0 and 1 indicating the largest observed p-value to be considered, i.e. larger observed p-values are filtered out and subsequent computation of critical values, adjusted p-values and rejection decisions are performed under the condition that raw p-values are smaller than or equal to \code{threshold}.}

\item{pCDFlist.indices}{list of numeric vectors containing the test indices that indicate to which p-value each \strong{unique} support in \code{pCDFlist} belongs; ignored if the lengths of \code{raw.pvalues} and \code{pCDFlist} are equal.}
}
\value{
A \code{DiscreteFDR} S3 class object whose elements are:
\item{Rejected}{rejected raw p-values.}
\item{Indices}{indices of rejected hypotheses.}
\item{Num.rejected}{number of rejections.}
\item{Adjusted}{adjusted p-values (only for step-down direction).}
\item{Critical.constants}{critical constants (if requested).}
\item{Select$Threshold}{p-value selection \code{threshold} (only present if \code{threshold} \eqn{< 1}).}
\item{Select$Effective.Thresholds}{results of each p-value CDF evaluated at the selection threshold (only present if \code{threshold} \eqn{< 1}).}
\item{Select$Pvalues}{selected p-values that are \eqn{\leq} selection \code{threshold} (only present if \code{threshold} \eqn{< 1}).}
\item{Select$Indices}{indices of p-values \eqn{\leq} selection \code{threshold} (only present if \code{threshold} \eqn{< 1}).}
\item{Select$Scaled}{scaled selected p-values, i.e. \eqn{\frac{i-th p-value}{i-th effective threshold}} (only present if \code{threshold} \eqn{< 1}).}
\item{Select$Number}{number of selected p-values \eqn{\leq} \code{threshold} (only present if \code{threshold} \eqn{< 1}).}
\item{Data$Method}{character string describing the used algorithm, e.g. 'Discrete Benjamini-Hochberg procedure (step-up)'}
\item{Data$raw.pvalues}{observed p-values.}
\item{Data$pCDFlist}{p-value supports.}
\item{Data$pCDFlist.indices}{observed p-value indices of the \strong{unique} p-value supports.}
\item{Data$FDR.level}{FDR level \code{alpha}.}
\item{Data$Data.name}{the respective variable names of the input data.}
}
\description{
Apply the [HSU], [HSD], [AHSU] and [AHSD] procedures at a given FDR
level, with or without computing the critical constants, to a set of p-values
and their respective discrete supports.
}
\details{
The adaptive variants [AHSU] and [AHSD], which are executed via
\code{adaptive = TRUE}, are often slightly more powerful than [HSU] and [HSD],
respectively. But they are also computationally more demanding.

Computing critical constants (\code{ret.crit.consts = TRUE}) requires considerably
more execution time, especially if the number of unique supports is large.
Users should only have them calculated when they need them, e.g. for
illustrating the rejection area in a plot or other theoretical reasons.
}
\examples{
X1 <- c(4, 2, 2, 14, 6, 9, 4, 0, 1)
X2 <- c(0, 0, 1, 3, 2, 1, 2, 2, 2)
N1 <- rep(148, 9)
N2 <- rep(132, 9)
Y1 <- N1 - X1
Y2 <- N2 - X2
df <- data.frame(X1, Y1, X2, Y2)
df

# Compute p-values and their supports of Fisher's exact test
test.result <- generate.pvalues(df, "fisher")
raw.pvalues <- test.result$get_pvalues()
pCDFlist <- test.result$get_pvalue_supports()

# DBH (SU) without critical values; using extracted p-values and supports
DBH.su.fast <- discrete.BH(raw.pvalues, pCDFlist)
summary(DBH.su.fast)

# DBH (SD) without critical values; using extracted p-values and supports
DBH.sd.fast <- discrete.BH(raw.pvalues, pCDFlist, direction = "sd")
summary(DBH.sd.fast)

# DBH (SU) with critical values; using test results
DBH.su.crit <- discrete.BH(test.result, ret.crit.consts = TRUE)
summary(DBH.su.crit)

# DBH (SD) with critical values; using test results
DBH.sd.crit <- discrete.BH(test.result, direction = "sd", ret.crit.consts = TRUE)
summary(DBH.sd.crit)

# ADBH (SU) without critical values; using extracted p-values and supports
ADBH.su.fast <- discrete.BH(raw.pvalues, pCDFlist, adaptive = TRUE)
summary(ADBH.su.fast)

# ADBH (SD) without critical values; using extracted p-values and supports
ADBH.sd.fast <- discrete.BH(raw.pvalues, pCDFlist, direction = "sd", adaptive = TRUE)
summary(ADBH.sd.fast)

# ADBH (SU) with critical values; using test results
ADBH.su.crit <- discrete.BH(test.result, adaptive = TRUE, ret.crit.consts = TRUE)
summary(ADBH.su.crit)

# ADBH (SD) with critical values; using test results
ADBH.sd.crit <- discrete.BH(test.result, direction = "sd", adaptive = TRUE, ret.crit.consts = TRUE)
summary(ADBH.sd.crit)

}
\references{
DÃ¶hler, S., Durand, G., & Roquain, E. (2018). New FDR bounds for discrete
and heterogeneous tests. \emph{Electronic Journal of Statistics}, \emph{12}(1),
pp. 1867-1900. \doi{10.1214/18-EJS1441}
}
\seealso{
\code{\link[=DBH]{DBH()}}, \code{\link[=ADBH]{ADBH()}}, \code{\link[=DBR]{DBR()}}
}
